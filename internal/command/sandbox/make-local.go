package sandbox

import (
	"fmt"
	"io"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/signadot/cli/internal/config"
	sbmapi "github.com/signadot/cli/internal/locald/api/sandboxmanager"
	sbmgr "github.com/signadot/cli/internal/locald/sandboxmanager"
	"github.com/signadot/cli/internal/print"
	"github.com/signadot/cli/internal/utils"
	"github.com/signadot/cli/internal/utils/system"
	"github.com/signadot/go-sdk/client/sandboxes"
	"github.com/signadot/go-sdk/models"
	"github.com/signadot/libconnect/common/processes"
	"github.com/spf13/cobra"
)

func newMakeLocal(sandbox *config.Sandbox) *cobra.Command {
	cfg := &config.SandboxMakeLocal{Sandbox: sandbox}

	cmd := &cobra.Command{
		Use:   "make-local",
		Short: "Make a local sandbox",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			var name string
			if len(args) == 1 {
				name = args[0]
			}
			return makeLocal(cfg, cmd.OutOrStdout(), name)
		},
	}

	cfg.AddFlags(cmd)
	return cmd
}

func makeLocal(cfg *config.SandboxMakeLocal, out io.Writer, name string) error {
	if err := cfg.InitAPIConfig(); err != nil {
		return err
	}

	if err := checkLocalConnected(); err != nil {
		return err
	}

	sandboxName := resolveSandboxName(name)

	namespace, workloadName, err := parseWorkload(cfg.Workload)
	if err != nil {
		return err
	}

	localMappings, err := parseLocalPortMappings(cfg.PortMappings)
	if err != nil {
		return err
	}

	if err := verifySandboxManager(cfg.Cluster); err != nil {
		return err
	}

	sbx, err := buildLocalSandbox(cfg, sandboxName, namespace, workloadName, localMappings)
	if err != nil {
		return err
	}

	params := sandboxes.NewApplySandboxParams().
		WithOrgName(cfg.Org).
		WithSandboxName(sandboxName).
		WithData(sbx)

	resp, err := cfg.Client.Sandboxes.ApplySandbox(params, nil)
	if err != nil {
		return err
	}

	if cfg.Wait {
		sbxApply := &config.SandboxApply{
			Wait:        cfg.Wait,
			WaitTimeout: cfg.WaitTimeout,
			Sandbox:     cfg.Sandbox,
		}

		waited, waitErr := waitForReady(sbxApply, out, resp.Payload)
		if waitErr != nil {
			// The sandbox was applied but may not be fully ready
			writeOutput(cfg.Sandbox, out, waited)
			fmt.Fprintf(out, "\nThe sandbox was applied, but it may not be ready yet. "+
				"To check status, run:\n\n  signadot sandbox get %v\n\n", sandboxName)
			return waitErr
		}
	}

	switch cfg.OutputFormat {
	case config.OutputFormatDefault:
		return printSandboxDetails(cfg.Sandbox, out, resp.Payload)
	case config.OutputFormatJSON:
		return print.RawJSON(out, resp.Payload)
	case config.OutputFormatYAML:
		return print.RawYAML(out, resp.Payload)
	default:
		return fmt.Errorf("unsupported output format: %q", cfg.OutputFormat)
	}
}

func checkLocalConnected() error {
	signadotDir, err := system.GetSignadotDir()
	if err != nil {
		return err
	}
	pidfile := filepath.Join(signadotDir, config.SandboxManagerPIDFile)

	isRunning, err := processes.IsDaemonRunning(pidfile)
	if err != nil {
		return err
	}
	if !isRunning {
		return fmt.Errorf("signadot is not connected\n")
	}
	return nil
}

func resolveSandboxName(name string) string {
	if len(name) > 0 {
		return name
	}
	return fmt.Sprintf("autogenerated-sandbox-%s", utils.RandomString(6))
}

func parseWorkload(raw string) (string, string, error) {
	if raw == "" {
		return "", "", fmt.Errorf("no workload defined\n")
	}

	parts := strings.Split(raw, "/")
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid workload format (expected namespace/name)")
	}

	ns := parts[0]
	wl := parts[1]
	if ns == "" || wl == "" {
		return "", "", fmt.Errorf("namespace or workload name cannot be empty")
	}

	return ns, wl, nil
}

func parseLocalPortMappings(portMappings []string) ([]*models.LocalPortMapping, error) {
	var mappings []*models.LocalPortMapping
	for _, m := range portMappings {
		parts := strings.SplitN(m, ":", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid port mapping %q", m)
		}

		containerPort, err := strconv.ParseInt(parts[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid container port %q: %v", parts[0], err)
		}

		mappings = append(mappings, &models.LocalPortMapping{
			Port:    containerPort,
			ToLocal: parts[1],
		})
	}
	return mappings, nil
}

// verifySandboxManager checks that sandbox-manager is ready and that the connected cluster matches the config.
func verifySandboxManager(expectedCluster string) error {
	status, err := sbmgr.GetStatus()
	if err != nil {
		return err
	}

	ciConfig, err := sbmapi.ToCIConfig(status.CiConfig)
	if err != nil {
		return fmt.Errorf("couldn't unmarshal ci-config from sandboxmanager status, %v", err)
	}

	connectErrs := sbmgr.CheckStatusConnectErrors(status, ciConfig)
	if len(connectErrs) != 0 {
		return fmt.Errorf("sandboxmanager is still starting")
	}

	if expectedCluster != ciConfig.ConnectionConfig.Cluster {
		return fmt.Errorf("sandbox spec cluster %q does not match connected cluster (%q)",
			expectedCluster, ciConfig.ConnectionConfig.Cluster)
	}
	return nil
}

// buildLocalSandbox constructs a Sandbox object for "local" usage.
func buildLocalSandbox(
	cfg *config.SandboxMakeLocal,
	name, namespace, workloadName string,
	localMappings []*models.LocalPortMapping,
) (*models.Sandbox, error) {
	localMachineID, err := system.GetMachineID()
	if err != nil {
		return nil, err
	}

	workloadKind := "Deployment"
	localSpec := &models.Local{
		From: &models.LocalFrom{
			Kind:      &workloadKind,
			Name:      &workloadName,
			Namespace: &namespace,
		},
		Mappings: localMappings,
		Name:     fmt.Sprintf("local-%s-%s", namespace, workloadName),
	}

	sbx := &models.Sandbox{
		Name: name,
		Spec: &models.SandboxSpec{
			Cluster:        &cfg.Cluster,
			Description:    "Generated local sandbox with signadot sandbox make-local",
			Local:          []*models.Local{localSpec},
			LocalMachineID: localMachineID,
		},
	}

	return sbx, nil
}
