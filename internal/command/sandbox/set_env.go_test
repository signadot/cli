package sandbox

import (
	"fmt"
	"io"
	"strings"

	"github.com/signadot/cli/internal/config"
	"github.com/signadot/cli/internal/print"
	"github.com/signadot/go-sdk/client/sandboxes"
	"github.com/signadot/go-sdk/models"
	"github.com/spf13/cobra"
)

func newSetEnv(sandbox *config.Sandbox) *cobra.Command {
	cfg := &config.SandboxSetEnv{Sandbox: sandbox}

	cmd := &cobra.Command{
		Use:   "set-env SANDBOX_NAME --workload=WORKLOAD_NAME KEY1=VALUE1 [KEY2=VALUE2 ...]",
		Short: "Set environment variables for a workload in a sandbox",
		Args:  cobra.MinimumNArgs(2), // SANDBOX_NAME and at least one KEY=VALUE pair
		RunE: func(cmd *cobra.Command, args []string) error {
			sandboxName := args[0]
			envVars := args[1:]
			return setEnv(cfg, cmd.OutOrStdout(), sandboxName, envVars)
		},
	}
	cfg.AddFlags(cmd)
	return cmd
}

func setEnv(cfg *config.SandboxSetEnv, out io.Writer, sandboxName string, envVars []string) error {
	if err := cfg.InitAPIConfig(); err != nil {
		return err
	}

	// Get the current sandbox
	params := sandboxes.NewGetSandboxParams().WithOrgName(cfg.Org).WithSandboxName(sandboxName)
	result, err := cfg.Client.Sandboxes.GetSandbox(params, nil)
	if err != nil {
		return fmt.Errorf("failed to get sandbox %q: %v", sandboxName, err)
	}
	sandbox := result.Payload

	// Find the workload and update its environment variables
	found := false
	for i, fork := range sandbox.Spec.Forks {
		if fork.ForkOf != nil && fork.ForkOf.Name != nil && *fork.ForkOf.Name == cfg.Workload {
			// Initialize customizations if not present
			if fork.Customizations == nil {
				fork.Customizations = &models.SandboxCustomizations{}
			}
			if fork.Customizations.Env == nil {
				fork.Customizations.Env = []*models.SandboxEnvVar{}
			}

			// Parse and add environment variables
			for _, envVar := range envVars {
				key, value, err := parseEnvVar(envVar)
				if err != nil {
					return fmt.Errorf("invalid environment variable format %q: %v", envVar, err)
				}

				envCustomization := &models.SandboxEnvVar{
					Name:      key,
					Value:     value,
					Operation: "upsert",
				}
				fork.Customizations.Env = append(fork.Customizations.Env, envCustomization)
			}

			sandbox.Spec.Forks[i] = fork
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("workload %q not found in sandbox %q", cfg.Workload, sandboxName)
	}

	// Apply the updated sandbox
	applyParams := sandboxes.NewApplySandboxParams().
		WithOrgName(cfg.Org).WithSandboxName(sandboxName).WithData(sandbox)
	_, err = cfg.Client.Sandboxes.ApplySandbox(applyParams, nil)
	if err != nil {
		return fmt.Errorf("failed to update sandbox %q: %v", sandboxName, err)
	}

	fmt.Fprintf(out, "Updated environment variables for workload %q in sandbox %q:\n", cfg.Workload, sandboxName)
	for _, envVar := range envVars {
		fmt.Fprintf(out, "  %s\n", envVar)
	}

	// Output the updated sandbox
	switch cfg.OutputFormat {
	case config.OutputFormatDefault:
		return nil // Already printed success message
	case config.OutputFormatJSON:
		return print.RawJSON(out, sandbox)
	case config.OutputFormatYAML:
		return print.RawYAML(out, sandbox)
	default:
		return fmt.Errorf("unsupported output format: %q", cfg.OutputFormat)
	}
}

func parseEnvVar(envVar string) (key, value string, err error) {
	parts := strings.SplitN(envVar, "=", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("expected format KEY=VALUE")
	}
	return parts[0], parts[1], nil
}
