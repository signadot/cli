package remote

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"sync"
	"time"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"github.com/signadot/cli/internal/auth"
	"github.com/signadot/cli/internal/buildinfo"
	"github.com/signadot/cli/internal/config"
	"github.com/signadot/go-sdk/client"
	sdkauth "github.com/signadot/go-sdk/client/auth"
	"github.com/signadot/go-sdk/transport"
	"github.com/spf13/viper"
)

// ... existing Remote struct and other methods remain the same ...

// refreshBearerToken refreshes an expired bearer token using the refresh token.
// This is similar to the implementation in internal/devbox/session_manager.go
func refreshBearerToken(authInfo *auth.ResolvedAuth) (*auth.ResolvedAuth, error) {
	// Create an unauthenticated API client for the refresh call
	apiURL := "https://api.signadot.com"
	if apiURLFromViper := viper.GetString("api_url"); apiURLFromViper != "" {
		apiURL = apiURLFromViper
	}

	cfg := &transport.APIConfig{
		APIURL:    apiURL,
		UserAgent: fmt.Sprintf("signadot-cli:%s", buildinfo.Version),
		Debug:     false,
	}

	t, err := transport.InitAPITransport(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to init unauthenticated API transport: %w", err)
	}

	unauthClient := client.New(t, nil)

	// Call the refresh endpoint
	params := &sdkauth.AuthDeviceRefreshTokenParams{
		Data: authInfo.RefreshToken,
	}

	resp, err := unauthClient.Auth.AuthDeviceRefreshToken(params)
	if err != nil {
		return nil, fmt.Errorf("failed to refresh token: %w", err)
	}

	expiresAt := time.Now().Add(time.Duration(resp.Payload.ExpiresIn) * time.Second)

	// Update auth info with new tokens
	newAuthInfo := &auth.ResolvedAuth{
		Source: authInfo.Source,
		Auth: auth.Auth{
			APIKey:       authInfo.APIKey,
			BearerToken:  resp.Payload.AccessToken,
			RefreshToken: resp.Payload.RefreshToken,
			OrgName:      authInfo.OrgName,
			ExpiresAt:    &expiresAt,
		},
	}

	// Save the refreshed token back to storage
	if err := saveRefreshedAuth(newAuthInfo); err != nil {
		// Log but don't fail - we can still use the refreshed token for this request
		// The next ResolveAuth() call will get the old token, but it will be refreshed again
		// In a real implementation, you'd want to log this via the Remote's logger
	}

	return newAuthInfo, nil
}

// saveRefreshedAuth saves the refreshed auth back to the storage (keyring or plaintext)
func saveRefreshedAuth(authInfo *auth.ResolvedAuth) error {
	switch authInfo.Source {
	case auth.KeyringAuthSource:
		keyringStorage := auth.NewKeyringStorage()
		return keyringStorage.Store(&authInfo.Auth)
	case auth.PlainTextAuthSource:
		plainTextStorage := auth.NewPlainTextStorage()
		return plainTextStorage.Store(&authInfo.Auth)
	default:
		// Config source doesn't need saving (it's in viper)
		return nil
	}
}

// Session returns the existing session or creates a new one if needed.
// When KeepAlive is enabled, it automatically handles health checks and closes
// the session if pings fail. This method will recreate the session if it was
// closed by KeepAlive or if no session exists.
//
// UPDATED VERSION WITH TOKEN REFRESH:
func (r *Remote) Session() (*mcp.ClientSession, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// If we have a session, return it. KeepAlive handles health checks automatically
	// and will close the session if pings fail. If the session was closed by KeepAlive,
	// operations will fail with ErrConnectionClosed and the tool handler will recreate it.
	if r.session != nil {
		return r.session, nil
	}

	// Resolve authentication information
	authInfo, err := auth.ResolveAuth()
	if err != nil {
		return nil, fmt.Errorf("failed to resolve auth: %w", err)
	}
	if !auth.IsAuthenticated(authInfo) {
		return nil, fmt.Errorf("not authenticated")
	}

	// NEW: Check if bearer token is expired and refresh if needed
	// This matches the pattern from internal/devbox/session_manager.go:createAPIClient
	if authInfo != nil && authInfo.BearerToken != "" && authInfo.APIKey == "" {
		if authInfo.ExpiresAt != nil && time.Now().After(*authInfo.ExpiresAt) {
			if authInfo.RefreshToken != "" {
				// Refresh the token
				r.log.Debug("bearer token expired, refreshing", "expiresAt", authInfo.ExpiresAt)
				refreshedAuth, err := refreshBearerToken(authInfo)
				if err != nil {
					return nil, fmt.Errorf("failed to refresh bearer token: %w", err)
				}
				authInfo = refreshedAuth
				r.log.Debug("bearer token refreshed successfully", "newExpiresAt", authInfo.ExpiresAt)
			} else {
				return nil, fmt.Errorf("bearer token expired and no refresh token available")
			}
		}
	}

	// Create HTTP transport with authentication headers
	transport := &mcp.StreamableClientTransport{
		Endpoint: r.cfg.MCPURL + "/stream",
		HTTPClient: &http.Client{
			Transport: &authTransport{
				RoundTripper: http.DefaultTransport,
				authInfo:     authInfo,
			},
		},
	}

	// Connect to the remote MCP server (use background context to avoid context
	// cancellation errors, this session will be used across multiple tool
	// calls)
	sess, err := r.client.Connect(context.Background(), transport, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to remote server: %w", err)
	}

	// Store the session for future use
	r.log.Debug("remote session created", "sessionID", sess.ID())
	r.session = sess
	return sess, nil
}
